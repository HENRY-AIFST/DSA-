# --------------------------------------------------------------
#  CAMPUS NAVIGATION & UTILITY PLANNER
#  Assignment 3 – Trees & Graphs (ENCS205 - Data Structures)
# --------------------------------------------------------------

# =======================
#   BUILDING DATA ADT
# =======================

class Building:
    def __init__(self, bid, name, location):
        self.building_id = bid
        self.building_name = name
        self.location = location


# =======================
#      BINARY SEARCH TREE
# =======================

class BSTNode:
    def __init__(self, building):
        self.data = building
        self.left = None
        self.right = None


class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, building):
        self.root = self._insert(self.root, building)

    def _insert(self, node, building):
        if node is None:
            return BSTNode(building)

        if building.building_id < node.data.building_id:
            node.left = self._insert(node.left, building)
        else:
            node.right = self._insert(node.right, building)

        return node

    def search(self, bid):
        return self._search(self.root, bid)

    def _search(self, node, bid):
        if node is None:
            return None
        if bid == node.data.building_id:
            return node.data
        elif bid < node.data.building_id:
            return self._search(node.left, bid)
        else:
            return self._search(node.right, bid)

    # Traversals
    def inorder(self):
        result = []
        self._inorder(self.root, result)
        return result

    def _inorder(self, node, result):
        if node:
            self._inorder(node.left, result)
            result.append(node.data.building_name)
            self._inorder(node.right, result)

    def preorder(self):
        result = []
        self._preorder(self.root, result)
        return result

    def _preorder(self, node, result):
        if node:
            result.append(node.data.building_name)
            self._preorder(node.left, result)
            self._preorder(node.right, result)

    def postorder(self):
        result = []
        self._postorder(self.root, result)
        return result

    def _postorder(self, node, result):
        if node:
            self._postorder(node.left, result)
            self._postorder(node.right, result)
            result.append(node.data.building_name)


# =======================
#           AVL TREE
# =======================

class AVLNode:
    def __init__(self, building):
        self.data = building
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    def __init__(self):
        self.root = None

    def height(self, node):
        return node.height if node else 0

    def balance_factor(self, node):
        return self.height(node.left) - self.height(node.right) if node else 0

    # Rotations
    def rotate_right(self, y):
        x = y.left
        T2 = x.right

        x.right = y
        y.left = T2

        y.height = 1 + max(self.height(y.left), self.height(y.right))
        x.height = 1 + max(self.height(x.left), self.height(x.right))

        return x

    def rotate_left(self, x):
        y = x.right
        T2 = y.left

        y.left = x
        x.right = T2

        x.height = 1 + max(self.height(x.left), self.height(x.right))
        y.height = 1 + max(self.height(y.left), self.height(y.right))

        return y

    # Insert
    def insert(self, building):
        self.root = self._insert(self.root, building)

    def _insert(self, node, building):
        if node is None:
            return AVLNode(building)

        if building.building_id < node.data.building_id:
            node.left = self._insert(node.left, building)
        else:
            node.right = self._insert(node.right, building)

        node.height = 1 + max(self.height(node.left), self.height(node.right))

        # Balance cases
        bf = self.balance_factor(node)

        # LL Case
        if bf > 1 and building.building_id < node.left.data.building_id:
            print("LL Rotation")
            return self.rotate_right(node)

        # RR Case
        if bf < -1 and building.building_id > node.right.data.building_id:
            print("RR Rotation")
            return self.rotate_left(node)

        # LR Case
        if bf > 1 and building.building_id > node.left.data.building_id:
            print("LR Rotation")
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)

        # RL Case
        if bf < -1 and building.building_id < node.right.data.building_id:
            print("RL Rotation")
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    # Traversals (same as BST)
    def inorder(self):
        result = []
        self._inorder(self.root, result)
        return result

    def _inorder(self, node, result):
        if node:
            self._inorder(node.left, result)
            result.append(node.data.building_name)
            self._inorder(node.right, result)


# =======================
#         GRAPH
# =======================

from collections import defaultdict
import heapq


class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.adj_list = defaultdict(list)
        self.adj_matrix = [[0] * vertices for _ in range(vertices)]

    def add_edge(self, u, v, w):
        self.adj_list[u].append((v, w))
        self.adj_list[v].append((u, w))

        self.adj_matrix[u][v] = w
        self.adj_matrix[v][u] = w

    # BFS
    def bfs(self, start):
        visited = [False] * self.V
        queue = [start]
        visited[start] = True
        result = []

        while queue:
            node = queue.pop(0)
            result.append(node)

            for neigh, _ in self.adj_list[node]:
                if not visited[neigh]:
                    visited[neigh] = True
                    queue.append(neigh)

        return result

    # DFS
    def dfs(self, start):
        visited = [False] * self.V
        result = []
        self._dfs(start, visited, result)
        return result

    def _dfs(self, node, visited, result):
        visited[node] = True
        result.append(node)
        for neigh, _ in self.adj_list[node]:
            if not visited[neigh]:
                self._dfs(neigh, visited, result)

    # Dijkstra – shortest path
    def dijkstra(self, src):
        dist = [float('inf')] * self.V
        dist[src] = 0
        pq = [(0, src)]

        while pq:
            d, u = heapq.heappop(pq)
            for v, w in self.adj_list[u]:
                if dist[v] > d + w:
                    dist[v] = d + w
                    heapq.heappush(pq, (dist[v], v))

        return dist

    # Kruskal – MST
    def kruskal(self):
        parent = list(range(self.V))

        def find(p):
            if parent[p] != p:
                parent[p] = find(parent[p])
            return parent[p]

        def union(a, b):
            pa = find(a)
            pb = find(b)
            parent[pa] = pb

        edges = []
        for u in range(self.V):
            for v, w in self.adj_list[u]:
                if u < v:
                    edges.append((w, u, v))

        edges.sort()

        mst = []
        for w, u, v in edges:
            if find(u) != find(v):
                union(u, v)
                mst.append((u, v, w))

        return mst


# =======================
#   EXPRESSION TREE
# =======================

class ExprNode:
    def __init__(self, value):
        self.value = value
        self.left = self.right = None


class ExpressionTree:
    def build(self, postfix):
        stack = []

        for char in postfix:
            if char.isdigit():
                stack.append(ExprNode(char))
            else:
                node = ExprNode(char)
                node.right = stack.pop()
                node.left = stack.pop()
                stack.append(node)

        return stack[-1]

    def evaluate(self, root):
        if root.value.isdigit():
            return int(root.value)
        a = self.evaluate(root.left)
        b = self.evaluate(root.right)

        if root.value == '+': return a + b
        if root.value == '-': return a - b
        if root.value == '*': return a * b
        if root.value == '/': return a // b


# =============================================================
#                     TESTING / DRIVER CODE
# =============================================================

if __name__ == "__main__":

    print("\n--- INSERTING BUILDINGS INTO BST & AVL ---\n")

    buildings = [
        Building(10, "Library", "Central Block"),
        Building(4, "CSE Dept", "North Wing"),
        Building(15, "Admin", "Main Gate"),
        Building(2, "Hostel A", "West Zone"),
        Building(7, "Cafeteria", "Food Court")
    ]

    bst = BinarySearchTree()
    avl = AVLTree()

    for b in buildings:
        bst.insert(b)
        avl.insert(b)

    print("BST Inorder:", bst.inorder())
    print("AVL Inorder:", avl.inorder())

    print("\nBST Height ≈ (not stored): Custom traversal based check")
    print("AVL Height:", avl.root.height)

    # ---- Graph Testing ----
    print("\n--- GRAPH TESTING ---\n")
    g = Graph(5)
    g.add_edge(0, 1, 2)
    g.add_edge(1, 2, 3)
    g.add_edge(0, 3, 6)
    g.add_edge(3, 4, 1)
    g.add_edge(2, 4, 5)

    print("BFS:", g.bfs(0))
    print("DFS:", g.dfs(0))

    print("Dijkstra:", g.dijkstra(0))
    print("Kruskal MST:", g.kruskal())

    # ---- Expression Tree ----
    print("\n--- EXPRESSION TREE ---\n")
    postfix = "52+3*"
    et = ExpressionTree()
    root = et.build(postfix)
    print(f"Expression (5 + 2) * 3 = {et.evaluate(root)}")
